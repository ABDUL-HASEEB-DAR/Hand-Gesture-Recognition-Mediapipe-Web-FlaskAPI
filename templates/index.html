<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Hand Gesture Control</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
      body {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        text-align: center;
        background: #ffffff;
        color: #1f1f1f;
      }
      video,
      canvas {
        transform: scaleX(-1);
        border-radius: 20px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }
      #gestures {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        margin-top: 20px;
      }
      .gesture-box {
        width: 100px;
        height: 100px;
        margin: 10px;
        border: 2px solid #000000;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        transition: background-color 0.3s;
        border-radius: 10px;
      }
      .active {
        background-color: #00aa00;
        color: white;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transform: scale(1.1) translateY(-5px);
        transition: all 0.3s ease;
      }
      #main {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        width: 70%;
        align-self: center;
      }
    </style>
  </head>
  <body>
    <h1>Hand Gesture Controlled Robot ws 1.1</h1>
    <div id="main">
      <div>
        <video
          id="video"
          width="640"
          height="480"
          autoplay
          muted
          playsinline
          style="display: none"
        ></video>
        <canvas id="canvas" width="640" height="480"></canvas>
      </div>

      <div id="gestures">
        <div id="gesture-0" class="gesture-box">Open</div>
        <div id="gesture-1" class="gesture-box">Close</div>
        <div id="gesture-2" class="gesture-box">Pointer</div>
        <div id="gesture-3" class="gesture-box">OK</div>
        <div id="gesture-4" class="gesture-box">Peace</div>
      </div>
    </div>

    <script>
      const socket = new WebSocket(
        "ws://hand-gesture-recognition-mediapipe-web.onrender.com/ws"
      ); // Replace with your actual backend URL

      const video = document.getElementById("video");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const username = prompt("Enter your username") || "Unknown";

      socket.addEventListener("open", () => {
        socket.send(JSON.stringify({ type: "join", username }));
      });

      socket.addEventListener("message", (event) => {
        const data = JSON.parse(event.data);
        if (data && typeof data.prediction !== "undefined") {
          updateGestureBoxes(data.prediction);
        }
      });

      const gestureBoxes = document.querySelectorAll(".gesture-box");

      function updateGestureBoxes(prediction) {
        gestureBoxes.forEach((box) => box.classList.remove("active"));
        if (prediction !== null && prediction >= 0 && prediction <= 4) {
          const box = document.getElementById(`gesture-${prediction}`);
          if (box) box.classList.add("active");
        }
      }

      function calcLandmarkList(image, landmarks) {
        const imageWidth = image.width;
        const imageHeight = image.height;
        return landmarks.map((lm) => [
          Math.min(Math.floor(lm.x * imageWidth), imageWidth - 1),
          Math.min(Math.floor(lm.y * imageHeight), imageHeight - 1),
        ]);
      }

      function preProcessLandmark(landmarkList) {
        let baseX = landmarkList[0][0];
        let baseY = landmarkList[0][1];

        let relCoords = landmarkList
          .map(([x, y]) => [x - baseX, y - baseY])
          .flat();
        const maxVal = Math.max(...relCoords.map(Math.abs)) || 1;
        return relCoords.map((v) => v / maxVal);
      }

      function sendMessage(landmark) {
        if (socket.readyState === WebSocket.OPEN && landmark) {
          socket.send(JSON.stringify({ type: "gesture", landmarks: landmark }));
        }
      }

      async function onResults(results) {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length > 0
        ) {
          const landmarks = results.multiHandLandmarks[0];
          drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {
            color: "#0f0",
            lineWidth: 2,
          });
          drawLandmarks(ctx, landmarks, { color: "#f00", lineWidth: 1 });

          const landmarkList = calcLandmarkList(canvas, landmarks);
          const processed = preProcessLandmark(landmarkList);
          sendMessage(processed);
        } else {
          updateGestureBoxes(null);
        }

        ctx.restore();
      }

      const hands = new Hands({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7,
      });

      hands.onResults(onResults);

      const camera = new Camera(video, {
        onFrame: async () => await hands.send({ image: video }),
        width: 640,
        height: 480,
      });

      camera.start();
    </script>
  </body>
</html>
